<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图片混淆工具</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 100;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
            background: linear-gradient(90deg, #ff7e5f, #feb47b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        .description {
            font-size: 1.1rem;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            color: #e0e0e0;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 30px;
            position: relative;
            z-index: 1000;
        }
        
        .btn {
            min-width: 140px;
            height: 50px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: all 0.5s;
        }
        
        .btn:hover:before {
            left: 100%;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #180161, #4f1787);
            color: white;
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, #eb3678, #fb773c);
            color: white;
        }
        
        .btn-file {
            background: linear-gradient(45deg, #0a8ea0, #00d4ff);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        .btn:active {
            transform: translateY(1px);
        }
        
        .file-input {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            opacity: 0;
            cursor: pointer;
        }
        
        .image-container {
            display: flex;
            justify-content: center;
            margin: 30px 0;
            position: relative;
            z-index: 100;
        }
        
        #display-img {
            max-width: 100%;
            max-height: 70vh;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            display: none;
            background: #0c0c0c;
            padding: 10px;
        }
        
        .info-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .info-panel h2 {
            margin-bottom: 15px;
            color: #feb47b;
        }
        
        .info-panel p {
            line-height: 1.6;
            margin-bottom: 10px;
        }
        
        .snow-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            font-size: 0.9rem;
            color: #aaa;
        }
        
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 100%;
                max-width: 300px;
            }
            
            h1 {
                font-size: 2.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="snow-container" id="snow-container"></div>
    
    <div class="container">
        <header>
            <h1>图片混淆工具</h1>
            <div class="description">
                基于空间填充曲线的新一代图片混淆技术。混淆算法保持像素的空间相关性，混淆图被压缩仍能保持色彩。此程序生成的图片格式为JPEG，质量0.95。
            </div>
        </header>
        
        <div class="controls">
            <button class="btn btn-file">
                选择图片
                <input type="file" accept="image/*" id="ipt" class="file-input">
            </button>
            <button id="enc" class="btn btn-primary">混淆图片</button>
            <button id="dec" class="btn btn-secondary">解混淆图片</button>
            <button id="re" class="btn btn-secondary">还原原图</button>
        </div>
        
        <div class="image-container">
            
        </div>
        
        <div class="info-panel">
            <h2>技术说明</h2>
            <p>• 使用Gilbert空间填充曲线对图像像素进行重排</p>
            <p>• 保持像素的空间相关性，使压缩后仍能保持色彩信息</p>
            <p>• 使用黄金比例(φ)作为偏移量，确保良好的混淆效果</p>
            <p>• 支持JPEG格式输出，质量设置为0.95</p>
        </div>
        
        <footer>
            <p>© 2023 图片混淆工具 | 仅供技术交流使用</p>
        </footer>
    </div>

    <script>
        // Gilbert空间填充曲线算法
        function gilbert2d(width, height) {
            const coordinates = [];
            
            if (width >= height) {
                generate2d(0, 0, width, 0, 0, height, coordinates);
            } else {
                generate2d(0, 0, 0, height, width, 0, coordinates);
            }
            
            return coordinates;
        }
        
        function generate2d(x, y, ax, ay, bx, by, coordinates) {
            const w = Math.abs(ax + ay);
            const h = Math.abs(bx + by);
            
            const dax = Math.sign(ax), day = Math.sign(ay);
            const dbx = Math.sign(bx), dby = Math.sign(by);
            
            if (h === 1) {
                for (let i = 0; i < w; i++) {
                    coordinates.push([x, y]);
                    x += dax;
                    y += day;
                }
                return;
            }
            
            if (w === 1) {
                for (let i = 0; i < h; i++) {
                    coordinates.push([x, y]);
                    x += dbx;
                    y += dby;
                }
                return;
            }
            
            let ax2 = Math.floor(ax / 2), ay2 = Math.floor(ay / 2);
            let bx2 = Math.floor(bx / 2), by2 = Math.floor(by / 2);
            
            const w2 = Math.abs(ax2 + ay2);
            const h2 = Math.abs(bx2 + by2);
            
            if (2 * w > 3 * h) {
                if ((w2 % 2) && (w > 2)) {
                    ax2 += dax;
                    ay2 += day;
                }
                
                generate2d(x, y, ax2, ay2, bx, by, coordinates);
                generate2d(x + ax2, y + ay2, ax - ax2, ay - ay2, bx, by, coordinates);
                
            } else {
                if ((h2 % 2) && (h > 2)) {
                    bx2 += dbx;
                    by2 += dby;
                }
                
                generate2d(x, y, bx2, by2, ax2, ay2, coordinates);
                generate2d(x + bx2, y + by2, ax, ay, bx - bx2, by - by2, coordinates);
                generate2d(x + (ax - dax) + (bx2 - dbx), y + (ay - day) + (by2 - dby),
                    -bx2, -by2, -(ax - ax2), -(ay - ay2), coordinates);
            }
        }
        
        // 图片处理功能
        const img = document.getElementById("display-img");
        
        function setsrc(src) {
            if (img.src) {
                URL.revokeObjectURL(img.src);
            }
            img.src = src;
            img.style.display = "block";
        }
        
        function encrypt(imgElement) {
            const cvs = document.createElement("canvas");
            const width = cvs.width = imgElement.width;
            const height = cvs.height = imgElement.height;
            const ctx = cvs.getContext("2d");
            ctx.drawImage(imgElement, 0, 0);
            const imgdata = ctx.getImageData(0, 0, width, height);
            const imgdata2 = new ImageData(width, height);
            const curve = gilbert2d(width, height);
            const offset = Math.round((Math.sqrt(5) - 1) / 2 * width * height);
            
            for (let i = 0; i < width * height; i++) {
                const old_pos = curve[i];
                const new_pos = curve[(i + offset) % (width * height)];
                const old_p = 4 * (old_pos[0] + old_pos[1] * width);
                const new_p = 4 * (new_pos[0] + new_pos[1] * width);
                imgdata2.data.set(imgdata.data.slice(old_p, old_p + 4), new_p);
            }
            
            ctx.putImageData(imgdata2, 0, 0);
            cvs.toBlob(b => {
                setsrc(URL.createObjectURL(b));
            }, "image/jpeg", 0.95);
        }
        
        function decrypt(imgElement) {
            const cvs = document.createElement("canvas");
            const width = cvs.width = imgElement.width;
            const height = cvs.height = imgElement.height;
            const ctx = cvs.getContext("2d");
            ctx.drawImage(imgElement, 0, 0);
            const imgdata = ctx.getImageData(0, 0, width, height);
            const imgdata2 = new ImageData(width, height);
            const curve = gilbert2d(width, height);
            const offset = Math.round((Math.sqrt(5) - 1) / 2 * width * height);
            
            for (let i = 0; i < width * height; i++) {
                const old_pos = curve[i];
                const new_pos = curve[(i + offset) % (width * height)];
                const old_p = 4 * (old_pos[0] + old_pos[1] * width);
                const new_p = 4 * (new_pos[0] + new_pos[1] * width);
                imgdata2.data.set(imgdata.data.slice(new_p, new_p + 4), old_p);
            }
            
            ctx.putImageData(imgdata2, 0, 0);
            cvs.toBlob(b => {
                setsrc(URL.createObjectURL(b));
            }, "image/jpeg", 0.95);
        }
        
        // 事件处理
        const ipt = document.getElementById("ipt");
        ipt.onchange = () => {
            if (ipt.files.length > 0) {
                setsrc(URL.createObjectURL(ipt.files[0]));
            }
        };
        
        const btn_enc = document.getElementById("enc");
        btn_enc.onclick = () => {
            if (img.src && img.complete) {
                img.style.display = "none";
                setTimeout(() => {
                    encrypt(img);
                }, 100);
            } else {
                alert("请先选择一张图片");
            }
        };
        
        const btn_dec = document.getElementById("dec");
        btn_dec.onclick = () => {
            if (img.src && img.complete) {
                img.style.display = "none";
                setTimeout(() => {
                    decrypt(img);
                }, 100);
            } else {
                alert("请先选择一张图片");
            }
        };
        
        const btn_restore = document.getElementById("re");
        btn_restore.onclick = () => {
            if (ipt.files.length > 0) {
                setsrc(URL.createObjectURL(ipt.files[0]));
            } else {
                alert("请先选择一张图片");
            }
        };
        
        // 简单的雪花效果（不会影响按钮点击）
        function createSnowEffect() {
            const snowContainer = document.getElementById('snow-container');
            const flakeCount = 50;
            
            for (let i = 0; i < flakeCount; i++) {
                const flake = document.createElement('div');
                flake.innerHTML = '❄';
                flake.style.position = 'absolute';
                flake.style.color = 'rgba(255, 255, 255, 0.7)';
                flake.style.fontSize = Math.random() * 20 + 10 + 'px';
                flake.style.userSelect = 'none';
                flake.style.pointerEvents = 'none';
                flake.style.zIndex = '1';
                
                const startPosX = Math.random() * 100;
                const startPosY = Math.random() * -20;
                const animationDuration = Math.random() * 10 + 10;
                const animationDelay = Math.random() * 20;
                
                flake.style.left = startPosX + 'vw';
                flake.style.top = startPosY + 'vh';
                
                flake.style.animation = `snowfall ${animationDuration}s linear ${animationDelay}s infinite`;
                
                snowContainer.appendChild(flake);
            }
            
            // 添加CSS动画
            const style = document.createElement('style');
            style.textContent = `
                @keyframes snowfall {
                    0% {
                        transform: translateY(0) translateX(0) rotate(0deg);
                        opacity: 0;
                    }
                    10% {
                        opacity: 1;
                    }
                    90% {
                        opacity: 1;
                    }
                    100% {
                        transform: translateY(100vh) translateX(20px) rotate(360deg);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        // 初始化雪花效果
        window.addEventListener('load', createSnowEffect);
    </script>
</body>
</html>
